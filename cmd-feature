#!/bin/bash

initialize() {
	require_git_repo
	require_gitflow_initialized
	gitflow_load_settings
	PREFIX=""
    HU_PREFIX="HU"
}

usage() {
	OPTIONS_SPEC="\
gitflow feature [help]	--> Display this message
gitflow feature list	--> Lists existing local feature branches
gitflow feature start	--> Start new feature from base
gitflow feature finish	--> Finish a feature (push, PRs, etc)
gitflow feature publish	--> Publish feature to origin
gitflow feature track	--> Get feature branch from origin
gitflow feature diff	--> Show all changes in feature branch vs base
gitflow feature checkout	--> Switch to feature branch
gitflow feature rebase	--> Rebase feature branch on base
gitflow feature pull	--> Pull feature branch from origin
gitflow feature delete	--> Delete feature branch
gitflow feature rename	--> Rename feature branch

Manage your feature branches.

For more specific help type the command followed by --help
--
"
	flags_help
}

cmd_default() {
	cmd_help "$@"
}

cmd_help() {
	usage
	exit 0
}

cmd_list() {
	OPTIONS_SPEC="\
gitflow feature list [-h] [-v]

Lists all the existing feature branches in the local repository.
--
h,help!     Show this help
v,verbose   Verbose (more) output
"
	local feature_branches current_branch width branch len
	local base aux_master_sha branch_sha

	# Define flags
	DEFINE_boolean 'verbose' false 'verbose (more) output' v

	# Parse argun=ments
	parse_args "$@"

	feature_branches=$(git_local_branches_prefixed "$HU_PREFIX")
	if [ -z "$feature_branches" ]; then
		warn "No feature branches exist."
		warn ""
		warn "You can start a new feature branch:"
		warn ""
		warn "    gitflow feature start <name> [<base>]"
		warn ""
		exit 0
	fi
	current_branch=$(git_current_branch)

	# Determine column width first
	width=0
	for branch in $feature_branches; do
		len=${#branch}
		width=$(max $width $len)
	done
	width=$(($width+3-${#PREFIX}))

	for branch in $feature_branches; do
		base=$(git merge-base "$branch" "$AUX_MASTER_BRANCH")
		aux_master_sha=$(git rev-parse "$AUX_MASTER_BRANCH")
		branch_sha=$(git rev-parse "$branch")
		if [ "$branch" = "$current_branch" ]; then
			printf "* "
		else
			printf "  "
		fi
		if flag verbose; then
			printf "%-${width}s" "${branch#$PREFIX}"
			if [ "$branch_sha" = "$aux_master_sha" ]; then
				printf "(no commits yet)"
			elif [ "$base" = "$branch_sha" ]; then
				printf "(is behind aux-master, may ff)"
			elif [ "$base" = "$aux_master_sha" ]; then
				printf "(based on latest aux-master)"
			else
				printf "(may be rebased)"
			fi
		else
			printf "%s" "${branch#$PREFIX}"
		fi
		echo
	done
}

# Parse arguments and set common variables
parse_args() {
	FLAGS "$@" || exit $?
	eval set -- "${FLAGS_ARGV}"

	# read arguments into global variables
	if [ -z $1 ]; then
		NAME=''
	else
		NAME=$1
	fi
	BRANCH=$PREFIX$NAME
}

parse_remote_name() {
	# Parse arguments
	FLAGS "$@" || exit $?
	eval set -- "${FLAGS_ARGV}"

	# read arguments into global variables
	if [ -z $1 ]; then
		REMOTE=''
	else
		REMOTE=$1
	fi

	if [ -z $2 ]; then
		NAME=''
	else
		NAME=$2
	fi
	BRANCH=$PREFIX$NAME
}

cmd_start() {
	OPTIONS_SPEC="\
gitflow feature start [-h] [-F] <name> [<base>]

Start new feature <name>, optionally basing it on <base> instead of <$AUX_MASTER_BRANCH>
By default, --fetch is used
--
h,help!          Show this help
showcommands!    Show git commands while executing them
F,[no]fetch      Pull base from origin before performing local operation. F and --nofetch set the flag to false. --fetch explicitly sets it to true (default)
"
	local base

	# Define flags
	DEFINE_boolean 'fetch' true 'fetch from origin before performing local operation' F

	# Override defaults with values from config
	gitflow_override_flag_boolean   "feature.start.fetch"   "fetch"

	# Parse arguments
	parse_args "$@"
	eval set -- "${FLAGS_ARGV}"
	base=${2:-$AUX_MASTER_BRANCH}

	require_clean_working_tree
	require_base_is_local_branch "$base"
	gitflow_require_name_arg
	require_feature_name

	# Sanity checks
	require_branch_absent "$BRANCH"

	# Update the local repo with remote changes, if asked
	if flag fetch; then
		git_do checkout "$base" || die "Failed to checkout to $base branch"
		git_do pull "$ORIGIN" "$base" || die "Failed to pull from remote '$REMOTE'."
		git_do fetch -q "origin" || die "Could not fetch branches from remote '$ORIGIN'."
	fi

	# If the origin branch counterpart exists, assert that the local branch
	# isn't behind it (to avoid unnecessary rebasing)
	if git_remote_branch_exists "origin/$base"; then
		require_branches_equal "$base" "origin/$base"
	fi

	# gitflow_config_set_base_branch $base $BRANCH

	# create branch
	gitflow_create_branch "$BRANCH" "$base"

	echo
	echo "Summary of actions:"
	echo "- A new branch '$BRANCH' was created, based on '$base'"
	echo "- You are now on branch '$(git_current_branch)'"
	echo ""
	echo "Now, start committing on your feature. When done, use:"
	echo ""
	echo "     gitflow feature finish $NAME"
	echo
}

cmd_finish() {
	OPTIONS_SPEC="\
gitflow feature finish [-h] [-F] [-r] [-p] [-k] [-D] [-S] [--no-ff] <name|nameprefix>

Finish feature <name>
By default, --fetch is used
--
h,help!                Show this help
showcommands!          Show git commands while executing them
F,[no]fetch            Fetch from origin before performing finish. F and --nofetch set the flag to false. --fetch explicitly sets it to true (default)
r,[no]rebase           Rebase before merging
p,[no]preserve-merges  Preserve merges while rebasing
S,[no]squash           Squash feature during merges
no-ff!                 Never fast-forward during merges
--
k,[no]keep             Always true -- Keep branch after performing finish
keepremote!        	   Always true -- Keep the remote branch
keeplocal!             Always true -- Keep the local branch
D,[no]force_delete     Unused -- Force delete feature branch after finish
"
	local merge_conflict stage_num finish_branch finish_base aux_dev_branch aux_qa_branch
	# finish_branch, finish_base will be used with merge conflicts

	# Define flags
	DEFINE_boolean 'fetch' true "fetch from $ORIGIN before performing finish" F
	DEFINE_boolean 'rebase' false "rebase before merging" r
	DEFINE_boolean 'preserve-merges' false 'try to recreate merges while rebasing' p
	DEFINE_boolean 'push' false "push to $ORIGIN after performing finish"
	DEFINE_boolean 'keep' false "keep branch after performing finish" k
	DEFINE_boolean 'keepremote' false "keep the remote branch"
	DEFINE_boolean 'keeplocal' false "keep the local branch"
	DEFINE_boolean 'force_delete' false "force delete feature branch after finish" D
	DEFINE_boolean 'squash' false "squash feature during merge" S
	DEFINE_boolean 'no-ff!' false "Don't fast-forward ever during merge "

	# Override defaults with values from config
	gitflow_override_flag_boolean   "feature.finish.fetch"             "fetch"
	gitflow_override_flag_boolean   "feature.finish.rebase"            "rebase"
	gitflow_override_flag_boolean   "feature.finish.preserve-merges"   "preserve_merges"
	gitflow_override_flag_boolean   "feature.finish.push"              "push"
	gitflow_override_flag_boolean   "feature.finish.keep"              "keep"
	gitflow_override_flag_boolean   "feature.finish.keepremote"        "keepremote"
	gitflow_override_flag_boolean   "feature.finish.keeplocal"         "keeplocal"
	gitflow_override_flag_boolean   "feature.finish.force-delete"      "force_delete"
	gitflow_override_flag_boolean   "feature.finish.squash"            "squash"
	gitflow_override_flag_boolean   "feature.finish.no-ff"             "no_ff"

	# Parse arguments
	parse_args "$@"

	# Use current branch if no name is given
	if [ "$NAME" = "" ]; then
		gitflow_set_name_as_current_branch
	fi
	require_feature_name_or_aux

	# Keeping both branches implies the --keep flag to be true.
	if flag keepremote && flag keeplocal; then
		FLAGS_keep=$FLAGS_TRUE
	fi

	# Sanity checks
	require_branch "$BRANCH"

	if ! github_check_authenticated; then
		echo "Your GitHub Personal Access Token is either invalid or has expired."
		echo "Please save your PAT in an environment variable 'GITHUB_PAT' (or in a .env file)"
		echo "You can then re-run the finish command by running it again:"
		echo "    gitflow feature finish $NAME"
		exit 1
	fi

	aux_dev_branch="$AUX_DEVELOP_PREFIX$BRANCH"
	aux_qa_branch="$AUX_QA_PREFIX$BRANCH"

	# BASE_BRANCH=$(gitflow_config_get_base_branch $BRANCH)
	BASE_BRANCH=${BASE_BRANCH:-$AUX_MASTER_BRANCH}
	git_local_branch_exists "$BASE_BRANCH" || die "The base '$BASE_BRANCH' doesn't exists locally or is not a branch. Can't finish the feature branch '$BRANCH'."

	# Detect if we're restoring from a merge conflict - include branch name in file
	if [ -f "$DOT_GIT_DIR/.gitflow/MERGE_BASE_$BRANCH" ]; then
		if git_is_clean_working_tree; then
			merge_conflict=$(cat "$DOT_GIT_DIR/.gitflow/MERGE_BASE_$BRANCH") # "$branch\\$base"
			finish_branch=$(cut -d'\' -f1 <<< "$merge_conflict")
			finish_base=$(cut -d'\' -f2 <<< "$merge_conflict")

			# Since the working tree is now clean, either the user did a
			# successful merge manually, or the merge was cancelled.
			# We detect this using git_is_branch_merged_into()
			if git_is_branch_merged_into "$finish_branch" "$finish_base"; then
				rm -f "$DOT_GIT_DIR/.gitflow/MERGE_BASE_$BRANCH"
				echo "Resuming after merge..."
				case $merge_conflict in
				"$BRANCH\\$aux_dev_branch")
					stage_num=1
					;;
				"$DEVELOP_BRANCH\\$aux_dev_branch")
					stage_num=2
					;;
				"$BRANCH\\$aux_qa_branch")
					stage_num=3
					;;
				"$QA_BRANCH\\$aux_qa_branch")
					stage_num=4
					;;
				*)
					echo "Invalid merge conflict saved: $merge_conflict."
					echo "Cancelling merge, please try running the command again."
					exit 1
					;;
				esac

				helper_finish_merges "$stage_num"
				exit 0
			else
				# If the user cancelled the merge and decided to wait until
				# later,that's fine. But we have to acknowledge this by
				# removing the MERGE_BASE file and continuing normal execution
				# of the finish
				rm -f "$DOT_GIT_DIR/.gitflow/MERGE_BASE_$BRANCH"
				echo "Cancelling merge and starting over..."
			fi
		else
			echo
			echo "Merge conflicts not resolved yet, use:"
			echo "    git mergetool"
			echo "Or just go to your project with your favorite IDE and it will prompt you to solve the conflicts."
			echo "Then, commit your merge. You can do this by running"
			echo "    git commit"
			echo
			echo "You can then complete the finish by running it again:"
			echo "    gitflow feature finish $NAME"
			echo
			echo "Alternatively, you can cancel your merge by running"
			echo "    git merge --abort"
			echo "Or just run feature finish again, we will cancel it for you"
			echo
			exit 1
		fi
	fi

	# Sanity checks
	require_clean_working_tree

	# Update local branches with remote branches
	# If not done and branches were fetched individually, new branches would not be fetched
	if flag fetch; then
		git_do fetch -q "origin" || die "Could not fetch branches from remote '$ORIGIN'."
	fi

	# Check if the local branches have all the commits from the remote branches
	# If remote does not exist, push feature branch to remote
	if git_remote_branch_exists "origin/$BRANCH"; then
		require_branch_equal_origin_or_push "$BRANCH"
	else 
		echo "Pushing $BRANCH to origin..."
		git_do push "$ORIGIN" "$BRANCH:$BRANCH" || die "Could not push branch '$BRANCH' to remote '$ORIGIN'."
	fi

	# Check that all other branches are up to date
	require_branches_equal_or_pull "$BASE_BRANCH" "origin/$BASE_BRANCH"
	require_branches_equal_or_pull "$DEVELOP_BRANCH" "origin/$DEVELOP_BRANCH"
	require_branches_equal_or_pull "$QA_BRANCH" "origin/$QA_BRANCH"

	# If the user wants to rebase, do that first
	if flag rebase; then
		local _rebase_opts=""
		if flag preserve_merges; then
			_rebase_opts="$_rebase_opts -p"
		fi
		if flag showcommands; then
			_rebase_opts="$_rebase_opts --showcommands"
		fi
		if ! cmd_rebase $_rebase_opts "$NAME"; then
			warn "Finish was aborted due to conflicts during rebase."
			warn "Please finish the rebase manually now."
			warn "When finished, re-run:"
			warn "    gitflow feature finish '$NAME' '$BASE_BRANCH'"
			exit 1
		fi
	fi

	# Original situation: 
	# 	- BASE_BRANCH = aux-master
	#	- Default flags
	#		* push, keep, keeplocal, keepremote = false
	# 	- Requires that feature branch, base branch are equal to origin
	# 	- Checkout to base branch
	# 	- Merge feature branch into base branch
	# 		* If merge conflicts, create MERGE_BASE file and exit
	# 		* After commiting merge conflicts and rerunning command, follows with next step 
	# 	- Push changes to base branch (if push == true)
	# 	- If keep == true, it ends here
	# 	- If keep == false
	# 		* If keepremote == false, delete remote feature branch
	# 		* If keeplocal == false, delete local feature branch

	# Desired situation: 
	# 	- BASE_BRANCH = aux-master
	#	- Default flags
	#		* push, keep, keeplocal, keepremote = true --> NOT USED
	# 	- Requires that feature branch, base branch, qa branch, develop branch are equal to origin
	# 	- Checkout to aux-dev/$NAME branch from feature branch
	#		* If branch does not exist, create a new aux-dev branch from feature branch
	#		* If branch exists, merge feature branch into aux-dev/$NAME branch
	#		* Merge develop branch into aux-dev/$NAME branch
	#			$ If merge conflicts, create MERGE_DEVELOP_TO_AUX_DEV file and exit
	#		* Push changes to aux-dev/$NAME branch
	#		* If open PR does not exist, create PR from aux-dev/$NAME branch to develop branch
	#			$ Include label develop
	# 	- Checkout to aux-qa/$NAME branch from feature branch
	#		* If branch does not exist, create a new aux-qa branch from feature branch
	#		* If branch exists, merge feature branch into aux-qa/$NAME branch
	#		* Merge qa branch into aux-qa/$NAME branch
	#			$ If merge conflicts, create MERGE_QA_TO_AUX_QA file and exit
	#		* Push changes to aux-qa/$NAME branch
	#		* If open PR does not exist, create PR from aux-qa/$NAME branch to qa branch
	#			$ Include label qa
	#	- If open PR does not exist, create PR from $NAME branch to aux-master branch
	#		* Include label aux-master

	helper_finish_merges
}

# 
# Performs merges, PRs, deletes, from finish feature cmd
#
# $1 stage - Number of merges already performed (defaults to 0)
#			 Helps when solving conflicts, to resume execution
#
helper_finish_merges(){
	local aux_dev_branch aux_qa_branch keepmsg stage_num print_arr
	aux_dev_branch="$AUX_DEVELOP_PREFIX$BRANCH"
	aux_qa_branch="$AUX_QA_PREFIX$BRANCH"
	stage_num="$1"
	[ -n "$1" ] || stage_num=0

	print_arr=()

	## STAGE 0
	if [ $stage_num -le 0 ]; then
		# Create or merge into aux-dev/$BRANCH
		if git_local_branch_exists "$aux_dev_branch"; then
			gitflow_merge_branch_to_base "$BRANCH" "$aux_dev_branch"
			print_arr+=("- Updated '$aux_dev_branch' with '$BRANCH'")
		else
			if git_remote_branch_exists "$aux_dev_branch"; then
				die "Branch $aux_dev_branch exists in $ORIGIN, but not found locally."
			else
				gitflow_create_branch "$aux_dev_branch" "$BRANCH"
				print_arr+=("- Created '$aux_dev_branch' with '$BRANCH'")
			fi
		fi
	fi

	## STAGE 1
	if [ $stage_num -le 1 ]; then
		# Merge develop into aux-dev/$BRANCH
		gitflow_merge_branch_to_base "$DEVELOP_BRANCH" "$aux_dev_branch"
		print_arr+=("- Merged '$DEVELOP_BRANCH' into '$aux_dev_branch'")
	fi

	## STAGE 2
	if [ $stage_num -le 2 ]; then
		# Create remote branch with remote tracking
		git_do push -u "$ORIGIN" "$aux_dev_branch:$aux_dev_branch" || die "Could not push branch '$aux_dev_branch' to remote '$ORIGIN'."
		git_do fetch -q "origin" "$aux_dev_branch" || die "Could not fetch branch '$aux_dev_branch' from remote '$ORIGIN'."
		print_arr+=("- Pushed aux branch '$aux_dev_branch' to '$ORIGIN'")

		# Create or merge into aux-qa/$BRANCH
		if git_local_branch_exists "$aux_qa_branch"; then
			gitflow_merge_branch_to_base "$BRANCH" "$aux_qa_branch"
			print_arr+=("- Updated '$aux_qa_branch' with '$BRANCH'")
		else
			if git_remote_branch_exists "$aux_qa_branch"; then
				die "Branch $aux_qa_branch exists in $ORIGIN, but not found locally."
			else
				gitflow_create_branch "$aux_qa_branch" "$BRANCH"
				print_arr+=("- Created '$aux_qa_branch' with '$BRANCH'")
			fi
		fi
	fi

	## STAGE 3
	if [ $stage_num -le 3 ]; then
		# Merge qa into aux-qa/$BRANCH
		gitflow_merge_branch_to_base "$QA_BRANCH" "$aux_qa_branch"
		print_arr+=("- Merged '$QA_BRANCH' into '$aux_qa_branch'")
	fi

	## STAGE 4

	# Create remote branch with remote tracking
	git_do push -u "$ORIGIN" "$aux_qa_branch:$aux_qa_branch" || die "Could not push branch '$aux_qa_branch' to remote '$ORIGIN'."
	git_do fetch -q "origin" "$aux_qa_branch" || die "Could not fetch branch '$aux_qa_branch' from remote '$ORIGIN'."
	print_arr+=("- Pushed aux branch '$aux_qa_branch' to '$ORIGIN'")

	local issue_number return_code tmp_file pr_body

	# Open editor to write PR body
	mkdir -p "$DOT_GIT_DIR/.gitflow"
	tmp_file="$DOT_GIT_DIR/.gitflow/pr_body.tmp"
	echo "Replace this text with your PR body for all new PRs..." > "$tmp_file"
	nano "$DOT_GIT_DIR/.gitflow/pr_body.tmp"
	pr_body=$(cat $tmp_file)
	rm "$tmp_file"

	print_arr+=("----------- PR -----------")
	# Create PR from $BRANCH branch to aux-master branch if not open (label: aux-master)
	issue_number=$(github_create_pr "$BRANCH" "$AUX_MASTER_BRANCH" "$pr_body")
	return_code="$?"
	if [ "$return_code" -eq 0 ]; then
		print_arr+=("- Created PR from $BRANCH to $AUX_MASTER_BRANCH: https://github.com/$GIT_USERNAME/$GIT_REPOSITORY/pull/$issue_number")
	else
		print_arr+=("- PR already open from $BRANCH to $AUX_MASTER_BRANCH: $(github_pr_search_url $BRANCH $AUX_MASTER_BRANCH)")
	fi

	# Create PR from $aux_dev_branch branch to develop branch if not open (label: develop)
	issue_number=$(github_create_pr "$aux_dev_branch" "$DEVELOP_BRANCH" "$pr_body")
	return_code="$?"
	if [ "$return_code" -eq 0 ]; then
		print_arr+=("- Created PR from $aux_dev_branch to $DEVELOP_BRANCH: https://github.com/$GIT_USERNAME/$GIT_REPOSITORY/pull/$issue_number")
	else
		print_arr+=("- PR already open from $aux_dev_branch to $DEVELOP_BRANCH: $(github_pr_search_url $aux_dev_branch $DEVELOP_BRANCH)")
	fi

	# Create PR from $aux_qa_branch branch to qa branch if not open (label: qa)
	issue_number=$(github_create_pr "$aux_qa_branch" "$QA_BRANCH" "$pr_body")
	return_code="$?"
	if [ "$return_code" -eq 0 ]; then
		print_arr+=("- Created PR from $aux_qa_branch to $QA_BRANCH: https://github.com/$GIT_USERNAME/$GIT_REPOSITORY/pull/$issue_number")
	else
		print_arr+=("- PR already open from $aux_qa_branch to $QA_BRANCH: $(github_pr_search_url $aux_qa_branch $QA_BRANCH)")
	fi
	print_arr+=("--------------------------")

	# Checkout back to feature branch
	git_do checkout "$BRANCH" || die "Could not check out branch '$BRANCH'."

	echo
	echo "Summary of actions:"
	echo "- Pushed feature branch '$BRANCH' to '$ORIGIN'"
	echo "- Pulled branches '$BASE_BRANCH', '$DEVELOP_BRANCH', '$QA_BRANCH' from '$ORIGIN'"
	for msg in "${print_arr[@]}"
	do
		echo $msg
	done
	keepmsg="is still locally available"
	if git_remote_branch_exists "origin/$BRANCH"; then
		keepmsg=$keepmsg"; it is still remotely available on '$ORIGIN'"
	fi
	echo "- Feature branch '$BRANCH' "$keepmsg
	echo "- You are now on branch '$(git_current_branch)'"
	echo
}

cmd_publish() {
	OPTIONS_SPEC="\
gitflow feature publish [-h] [<name>]

Publish feature branch <name> on $ORIGIN.
When <name> is omitted the current branch is used, but only if it's a feature branch.
--
h,help!          Show this help
showcommands!    Show git commands while executing them
"
	# Parse arguments
	parse_args "$@"

	# Use current branch if no name is given
	if [ "$NAME" = "" ]; then
		gitflow_set_name_as_current_branch
	fi
	require_feature_name

	# Sanity checks
	require_clean_working_tree
	require_branch "$BRANCH"
	git_do fetch -q "origin" || die "Could not fetch branch '$BRANCH' from remote '$ORIGIN'."

	# Create remote branch with remote tracking
	git_do push -u "$ORIGIN" "$BRANCH:$BRANCH" || die "Could not push branch '$BRANCH' to remote '$ORIGIN'."
	git_do fetch -q "origin" "$BRANCH" || die "Could not fetch branch '$BRANCH' from remote '$ORIGIN'."
	git_do checkout "$BRANCH" || die "Could not check out branch '$BRANCH'."

	echo
	echo "Summary of actions:"
	echo "- The remote branch '$BRANCH' was created or updated"
	echo "- The local branch '$BRANCH' was configured to track the remote branch"
	echo "- You are now on branch '$(git_current_branch)'"
	echo
}

cmd_track() {
	OPTIONS_SPEC="\
gitflow feature track [-h] <name>

Start tracking feature <name> that is shared on $ORIGIN
--
h,help!          Show this help
showcommands!    Show git commands while executing them
"
	# Parse arguments
	parse_args "$@"

	gitflow_require_name_arg

	# Sanity checks
	require_clean_working_tree
	require_local_branch_absent "$BRANCH"

	git_do fetch -q "origin" || die "Could not fetch branch '$BRANCH' from remote '$ORIGIN'."
	require_remote_branch "origin/$BRANCH"

	# Create tracking branch
	gitflow_create_branch "$BRANCH" "origin/$BRANCH"

	echo
	echo "Summary of actions:"
	echo "- A new remote tracking branch '$BRANCH' was created"
	echo "- You are now on branch '$(git_current_branch)'"
	echo
}

cmd_diff() {
	OPTIONS_SPEC="\
gitflow feature diff [-h] [<name|nameprefix>]

Show all changes in <name> that are not in the base.
Local branch <name> may or may not be a feature branch
--
h,help!          Show this help
showcommands!    Show git commands while executing them
"
	local base

	# Parse arguments
	parse_args "$@"

	# Use current branch if no name is given
	if [ "$NAME" = "" ]; then
		gitflow_set_name_as_current_branch
	fi
	require_local_branch "$BRANCH"

	# base=$(gitflow_config_get_base_branch $BRANCH)
	base=${base:-$AUX_MASTER_BRANCH}

	git_do diff "$base...$BRANCH"
}

cmd_checkout() {
	OPTIONS_SPEC="\
gitflow feature checkout [-h] [<name|nameprefix>]

Switch to feature branch <name>
--
h,help!          Show this help
showcommands!    Show git commands while executing them
"
	# Parse arguments
	parse_args "$@"

	gitflow_require_name_arg
	require_feature_name

	NAME=$(gitflow_resolve_nameprefix "$NAME" "$PREFIX")
	if [ $? -eq 0 ]; then
		BRANCH=$PREFIX$NAME
		git_do checkout "$BRANCH"  || die "Could not check out branch '$BRANCH'."
	fi
}

cmd_co() {
	# Alias for checkout
	cmd_checkout "$@"
}

cmd_rebase() {
	OPTIONS_SPEC="\
gitflow feature rebase [-h] [-i] [-p] [<name|nameprefix>]

Rebase <name> on <base_branch>
--
h,help!                Show this help
showcommands!          Show git commands while executing them
i,[no]interactive      Do an interactive rebase
p,[no]preserve-merges  Preserve merges
"
	local opts

	# Define flags
	DEFINE_boolean 'interactive' false 'do an interactive rebase' i
	DEFINE_boolean 'preserve-merges' false 'try to recreate merges' p

	# Override defaults with values from config
	gitflow_override_flag_boolean   "feature.rebase.interactive"       "interactive"
	gitflow_override_flag_boolean   "feature.rebase.preserve-merges"   "preserve_merges"

	# Parse arguments
	parse_args "$@"

	# Use current branch if no name is given
	if [ "$NAME" = "" ]; then
		gitflow_set_name_as_current_branch
	fi
	require_feature_name

	# BASE_BRANCH=$(gitflow_config_get_base_branch $BRANCH)
	BASE_BRANCH=${BASE_BRANCH:-$AUX_MASTER_BRANCH}

	warn "Will try to rebase '$NAME' which is based on '$BASE_BRANCH'..."
	if ! git_config_bool_exists "rebase.autostash"; then
		require_clean_working_tree
	fi

	require_branch "$BRANCH"

	git_local_branch_exists "$BASE_BRANCH" || die "The base '$BASE_BRANCH' doesn't exists locally or is not a branch. Can't rebase the feature branch '$BRANCH'."

	git_do checkout -q "$BRANCH" || die "Could not check out branch '$BRANCH'."
	if flag interactive; then
		opts="$opts -i"
	fi
	if flag preserve_merges; then
		opts="$opts -p"
	fi
	git_do rebase $opts "$BASE_BRANCH" || die "Could not rebase '$BRANCH' from '$BASE_BRANCH'."
}

cmd_pull() {
	OPTIONS_SPEC="\
gitflow feature pull [-h] [<remote>]

Pull feature <current_branch> from <remote>. 
Allows to update current feature branch.
If local branch does not exist, use gitflow feature track.
--
h,help!          Show this help
showcommands!    Show git commands while executing them
r,[no]rebase     Pull with rebase
"
	local current_branch

	# Define flags
	DEFINE_boolean 'rebase' false "pull with rebase" r

	# Parse arguments
	parse_remote_name "$@"

	if [ "$REMOTE" = "" ]; then
		REMOTE="$ORIGIN"
	fi

	gitflow_use_current_branch_name
	require_feature_name
	require_clean_working_tree

	if ! git_remote_branch_exists "origin/$NAME"; then
		warn "Branch 'origin/$NAME' does not exist in $REMOTE."
		exit 0
	fi

	# We already have a local branch called like this, so simply pull the remote changes in
	if flag rebase; then
		if ! git_do pull --rebase -q "$REMOTE" "$BRANCH"; then
			die "Pull was aborted. There might be conflicts during rebase or '$REMOTE' might be inaccessible."
		fi
	else
		git_do pull "$REMOTE" "$BRANCH" || die "Failed to pull from remote '$REMOTE'."
	fi

	echo "Pulled $REMOTE's changes into $BRANCH."
}

cmd_delete() {
	OPTIONS_SPEC="\
gitflow feature delete [-h] [-f] [-r] <name>

Delete a given feature branch
--
h,help!          Show this help
showcommands!    Show git commands while executing them
f,[no]force      Force deletion
r,[no]remote     Delete remote branch. This will also close open PRs without merging them
"
	local current_branch aux_dev_branch aux_qa_branch branch_arr print_arr

	# Define flags
	DEFINE_boolean 'force' false "force deletion" f
	DEFINE_boolean 'remote' false "delete remote branch" r

	# Override defaults with values from config
	gitflow_override_flag_boolean   "feature.delete.force"    "force"
	gitflow_override_flag_boolean   "feature.delete.remote"   "remote"

	# Parse arguments
	parse_args "$@"

	gitflow_require_name_arg
	require_feature_name

	# Require clean working tree, as we might need to checkout to other branch
	require_clean_working_tree

	# Update references from remote
	git_do fetch -q "origin" || die "Could not fetch from remote '$ORIGIN'."

	# BASE_BRANCH=$(gitflow_config_get_base_branch $BRANCH)
	BASE_BRANCH=${BASE_BRANCH:-$AUX_MASTER_BRANCH}
	git_local_branch_exists "$BASE_BRANCH" || die "The base '$BASE_BRANCH' doesn't exists locally or is not a branch. Can't delete the feature branch '$BRANCH'."

	current_branch=$(git_current_branch)
	print_arr=()

	branch_arr=("$BRANCH" "$AUX_DEVELOP_PREFIX$BRANCH" "$AUX_QA_PREFIX$BRANCH")
	bases_arr=("$AUX_MASTER_BRANCH" "$DEVELOP_BRANCH" "$QA_BRANCH")

	for i in "${!branch_arr[@]}"; do
		if [ "${branch_arr[$i]}" = "$current_branch" ]; then
			git_do checkout "$BASE_BRANCH" || die "Could not check out branch '$BASE_BRANCH'."
		fi
		if git_local_branch_exists "${branch_arr[$i]}"; then
			if ! git_is_branch_merged_into "${branch_arr[$i]}" "${bases_arr[$i]}" && ! flag force; then
				warn "Skipping branch ${branch_arr[$i]}, which has not been merged into ${bases_arr[$i]} yet. Use -f to force its deletion."
				continue
			fi
			git_local_branch_delete "${branch_arr[$i]}"
			print_arr+=("- Deleted local branch '${branch_arr[$i]}'")
		fi
		if flag remote && git_remote_branch_exists "origin/${branch_arr[$i]}"; then
			git_remote_branch_delete "${branch_arr[$i]}"
			print_arr+=("- Deleted remote branch 'origin/${branch_arr[$i]}'")
		fi
	done

	echo
	echo "Summary of actions:"
	for msg in "${print_arr[@]}"; do
		echo $msg
	done
	echo
	echo "- You are now on branch '$(git_current_branch)'"
	echo
}

cmd_rename() {
	OPTIONS_SPEC="\
gitflow feature rename <new_name> [<name>]

Rename a given feature branch locally.
When <name> is omitted the current branch is used, but only if it's a feature branch.
--
h,help!          Show this help
showcommands!    Show git commands while executing them
"
	gitflow_rename_branch "$@"
}
